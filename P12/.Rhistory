n <- floor(log(k-1, 2)) + 1
neuronas <- matrix(runif(n * dim), nrow=n, ncol=dim) # perceptrones
for (t in 1:1) { # entrenamiento
d <- sample(0:tope, 1)
pixeles <- runif(dim) < modelos[d + 1,]
correcto <- binario(d, n)
for (i in 1:n) {
w <- neuronas[i,]
deseada <- correcto[i]
resultado <- sum(w * pixeles) >= 0
if (deseada != resultado) {
ajuste <- tasa * (deseada - resultado)
tasa <- tranqui * tasa
neuronas[i,] <- w + ajuste * pixeles
}
}
}
t
d
pixeles
modelos
modelos[2,]
runif(dim)
correcto
i
w
deseada
resultado
deseada!=resultado
source('~/GitHub/SimulacionComputacional/P12/P12.R', echo=TRUE)
contadores
source('~/GitHub/SimulacionComputacional/P12/P12.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P12/P12.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P12/P12.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P12/P12.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P12/P12.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P12/P12.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P12/P12.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P12/P12.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P12/P12.R', echo=TRUE)
View(contadores)
source('~/GitHub/SimulacionComputacional/P12/P12.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P12/P12.R', echo=TRUE)
suppressMessages(library(doParallel))
registerDoParallel(makeCluster(detectCores() - 1))
binario <- function(d, l) {
b <-  rep(FALSE, l)
while (l > 0 | d > 0) {
b[l] <- (d %% 2 == 1)
l <- l - 1
d <- bitwShiftR(d, 1)
}
return(b)
}
decimal <- function(bits, l) {
valor <- 0
for (pos in 1:l) {
valor <- valor + 2^(l - pos) * bits[pos]
}
return(valor)
}
modelos <- read.csv("digitos.modelo", sep=" ", header=FALSE, stringsAsFactors=F)
modelos[modelos=='n'] <- 0.995
modelos[modelos=='g'] <- 0.92
modelos[modelos=='b'] <- 0.002
r <- 5
c <- 3
dim <- r * c
tasa <- 0.15
tranqui <- 0.99
tope <- 9
digitos <- 0:tope
k <- length(digitos)
n <- floor(log(k-1, 2)) + 1
neuronas <- matrix(runif(n * dim), nrow=n, ncol=dim) # perceptrones
for (t in 1:5000) { # entrenamiento
d <- sample(0:tope, 1)
pixeles <- runif(dim) < modelos[d + 1,]
correcto <- binario(d, n)
for (i in 1:n) {
w <- neuronas[i,]
deseada <- correcto[i]
resultado <- sum(w * pixeles) >= 0
if (deseada != resultado) {
ajuste <- tasa * (deseada - resultado)
tasa <- tranqui * tasa
neuronas[i,] <- w + ajuste * pixeles
}
}
}
correcto
correcto[i]
w
deseada
correcto[i]
resultado
pixeles
modelos
suppressMessages(library(doParallel))
registerDoParallel(makeCluster(detectCores() - 1))
binario <- function(d, l) {
b <-  rep(FALSE, l)
while (l > 0 | d > 0) {
b[l] <- (d %% 2 == 1)
l <- l - 1
d <- bitwShiftR(d, 1)
}
return(b)
}
decimal <- function(bits, l) {
valor <- 0
for (pos in 1:l) {
valor <- valor + 2^(l - pos) * bits[pos]
}
return(valor)
}
modelos <- read.csv("digitos.modelo", sep=" ", header=FALSE, stringsAsFactors=F)
modelos[modelos=='n'] <- 0.995
modelos[modelos=='g'] <- 0.92
modelos[modelos=='b'] <- 0.002
r <- 5
c <- 3
dim <- r * c
tasa <- 0.15
tranqui <- 0.99
tope <- 9
digitos <- 0:tope
k <- length(digitos)
n <- floor(log(k-1, 2)) + 1
neuronas <- matrix(runif(n * dim), nrow=n, ncol=dim) # perceptrones
for (t in 1:5000) { # entrenamiento
d <- sample(0:tope, 1)
pixeles <- runif(dim) < modelos[d + 1,]
correcto <- binario(d, n)
for (i in 1:n) {
w <- neuronas[i,]
deseada <- correcto[i]
resultado <- sum(w * pixeles) >= 0 #Si la suma es mayor o igual a 0 la salida del perceptrón = TRUE
if (deseada != resultado) {
ajuste <- tasa * (deseada - resultado)
tasa <- tranqui * tasa
neuronas[i,] <- w + ajuste * pixeles
}
}
}
modelos
neuronas
0.99*0.99
suppressMessages(library(doParallel))
registerDoParallel(makeCluster(detectCores() - 1))
binario <- function(d, l) {
b <-  rep(FALSE, l)
while (l > 0 | d > 0) {
b[l] <- (d %% 2 == 1)
l <- l - 1
d <- bitwShiftR(d, 1)
}
return(b)
}
decimal <- function(bits, l) {
valor <- 0
for (pos in 1:l) {
valor <- valor + 2^(l - pos) * bits[pos]
}
return(valor)
}
modelos <- read.csv("digitos.modelo", sep=" ", header=FALSE, stringsAsFactors=F)
modelos[modelos=='n'] <- 0.995
modelos[modelos=='g'] <- 0.92
modelos[modelos=='b'] <- 0.002
r <- 5
c <- 3
dim <- r * c
tope <- 9
digitos <- 0:tope
k <- length(digitos)
n <- floor(log(k-1, 2)) + 1
neuronas <- matrix(runif(n * dim), nrow=n, ncol=dim) # perceptrones
for (t in 1:1) { # entrenamiento
d <- sample(0:tope, 1)
pixeles <- runif(dim) < modelos[d + 1,]
correcto <- binario(d, n)
entrenar<- function (){
tasa <- 0.15
tranqui <- 0.99
#  for (i in 1:n) {
w <- neuronas[i,]
deseada <- correcto[i]
resultado <- sum(w * pixeles) >= 0 #Si la suma es mayor o igual a 0 la salida del perceptrón = TRUE
if (deseada != resultado) {
ajuste <- tasa * (deseada - resultado)
tasa <- tranqui * tasa
w <- w + ajuste * pixeles
}
}
neuronas <- foreach(i=1:n, .combine = rbind) %dopar% entrenar(i)
}
suppressMessages(library(doParallel))
registerDoParallel(makeCluster(detectCores() - 1))
binario <- function(d, l) {
b <-  rep(FALSE, l)
while (l > 0 | d > 0) {
b[l] <- (d %% 2 == 1)
l <- l - 1
d <- bitwShiftR(d, 1)
}
return(b)
}
decimal <- function(bits, l) {
valor <- 0
for (pos in 1:l) {
valor <- valor + 2^(l - pos) * bits[pos]
}
return(valor)
}
modelos <- read.csv("digitos.modelo", sep=" ", header=FALSE, stringsAsFactors=F)
modelos[modelos=='n'] <- 0.995
modelos[modelos=='g'] <- 0.92
modelos[modelos=='b'] <- 0.002
r <- 5
c <- 3
dim <- r * c
tope <- 9
digitos <- 0:tope
k <- length(digitos)
n <- floor(log(k-1, 2)) + 1
neuronas <- matrix(runif(n * dim), nrow=n, ncol=dim) # perceptrones
for (t in 1:1) { # entrenamiento
d <- sample(0:tope, 1)
pixeles <- runif(dim) < modelos[d + 1,]
correcto <- binario(d, n)
entrenar<- function (i){
tasa <- 0.15
tranqui <- 0.99
#  for (i in 1:n) {
w <- neuronas[i,]
deseada <- correcto[i]
resultado <- sum(w * pixeles) >= 0 #Si la suma es mayor o igual a 0 la salida del perceptrón = TRUE
if (deseada != resultado) {
ajuste <- tasa * (deseada - resultado)
tasa <- tranqui * tasa
w <- w + ajuste * pixeles
}
}
neuronas <- foreach(i=1:n, .combine = rbind) %dopar% entrenar(i)
}
neuronas
tasa
suppressMessages(library(doParallel))
registerDoParallel(makeCluster(detectCores() - 1))
binario <- function(d, l) {
b <-  rep(FALSE, l)
while (l > 0 | d > 0) {
b[l] <- (d %% 2 == 1)
l <- l - 1
d <- bitwShiftR(d, 1)
}
return(b)
}
decimal <- function(bits, l) {
valor <- 0
for (pos in 1:l) {
valor <- valor + 2^(l - pos) * bits[pos]
}
return(valor)
}
modelos <- read.csv("digitos.modelo", sep=" ", header=FALSE, stringsAsFactors=F)
modelos[modelos=='n'] <- 0.995
modelos[modelos=='g'] <- 0.92
modelos[modelos=='b'] <- 0.002
r <- 5
c <- 3
dim <- r * c
tope <- 9
digitos <- 0:tope
k <- length(digitos)
n <- floor(log(k-1, 2)) + 1
neuronas <- matrix(runif(n * dim), nrow=n, ncol=dim) # perceptrones
for (t in 1:10) { # entrenamiento
d <- sample(0:tope, 1)
pixeles <- runif(dim) < modelos[d + 1,]
correcto <- binario(d, n)
entrenar<- function (i){
tasa <- 0.15
tranqui <- 0.99
#  for (i in 1:n) {
w <- neuronas[i,]
deseada <- correcto[i]
resultado <- sum(w * pixeles) >= 0 #Si la suma es mayor o igual a 0 la salida del perceptrón = TRUE
if (deseada != resultado) {
ajuste <- tasa * (deseada - resultado)
tasa <- tranqui * tasa
w <- w + ajuste * pixeles
}
}
neuronas <- foreach(i=1:n, .combine = rbind) %dopar% entrenar(i)
}
source('~/GitHub/SimulacionComputacional/P12/P12.R', echo=TRUE)
traceback()
suppressMessages(library(doParallel))
registerDoParallel(makeCluster(detectCores() - 1))
binario <- function(d, l) {
b <-  rep(FALSE, l)
while (l > 0 | d > 0) {
b[l] <- (d %% 2 == 1)
l <- l - 1
d <- bitwShiftR(d, 1)
}
return(b)
}
decimal <- function(bits, l) {
valor <- 0
for (pos in 1:l) {
valor <- valor + 2^(l - pos) * bits[pos]
}
return(valor)
}
modelos <- read.csv("digitos.modelo", sep=" ", header=FALSE, stringsAsFactors=F)
modelos[modelos=='n'] <- 0.995
modelos[modelos=='g'] <- 0.92
modelos[modelos=='b'] <- 0.002
r <- 5
c <- 3
dim <- r * c
tope <- 9
digitos <- 0:tope
k <- length(digitos)
n <- floor(log(k-1, 2)) + 1
neuronas <- matrix(runif(n * dim), nrow=n, ncol=dim) # perceptrones
for (t in 1:10) { # entrenamiento
d <- sample(0:tope, 1)
pixeles <- runif(dim) < modelos[d + 1,]
correcto <- binario(d, n)
entrenar<- function (){
tasa <- 0.15
tranqui <- 0.99
#  for (i in 1:n) {
w <- neuronas[i,]
deseada <- correcto[i]
resultado <- sum(w * pixeles) >= 0 #Si la suma es mayor o igual a 0 la salida del perceptrón = TRUE
if (deseada != resultado) {
ajuste <- tasa * (deseada - resultado)
tasa <- tranqui * tasa
w <- w + ajuste * pixeles
}
return(neuronas)
}
neuronas <- foreach(i=1:n, .combine = rbind) %dopar% entrenar()
}
neuronas
View(neuronas)
suppressMessages(library(doParallel))
registerDoParallel(makeCluster(detectCores() - 1))
binario <- function(d, l) {
b <-  rep(FALSE, l)
while (l > 0 | d > 0) {
b[l] <- (d %% 2 == 1)
l <- l - 1
d <- bitwShiftR(d, 1)
}
return(b)
}
decimal <- function(bits, l) {
valor <- 0
for (pos in 1:l) {
valor <- valor + 2^(l - pos) * bits[pos]
}
return(valor)
}
modelos <- read.csv("digitos.modelo", sep=" ", header=FALSE, stringsAsFactors=F)
modelos[modelos=='n'] <- 0.995
modelos[modelos=='g'] <- 0.92
modelos[modelos=='b'] <- 0.002
r <- 5
c <- 3
dim <- r * c
tope <- 9
digitos <- 0:tope
k <- length(digitos)
n <- floor(log(k-1, 2)) + 1
neuronas <- matrix(runif(n * dim), nrow=n, ncol=dim) # perceptrones
for (t in 1:10) { # entrenamiento
d <- sample(0:tope, 1)
pixeles <- runif(dim) < modelos[d + 1,]
correcto <- binario(d, n)
entrenar<- function (){
tasa <- 0.15
tranqui <- 0.99
#  for (i in 1:n) {
w <- neuronas[i,]
deseada <- correcto[i]
resultado <- sum(w * pixeles) >= 0 #Si la suma es mayor o igual a 0 la salida del perceptrón = TRUE
if (deseada != resultado) {
ajuste <- tasa * (deseada - resultado)
tasa <- tranqui * tasa
w <- w + ajuste * pixeles
}
return(w)
}
neuronas <- foreach(i=1:n, .combine = rbind) %dopar% entrenar()
}
neuronas
source('~/GitHub/SimulacionComputacional/P12/P12.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P12/P12.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P12/P12.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P12/P12.R', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P12/P12.R', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P12/P12.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P12/P12.R', echo=TRUE)
w
n
salida
d
source('~/GitHub/SimulacionComputacional/P12/P12.R', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P12/P12.R', echo=TRUE)
sample(1:4,1)
sample(1:4,1)
comida<-c(1,4,5,6,7,7,7,9)
mode(comida)
mean(comida)
mean(round(comida))
round(mean(comida))
source('~/GitHub/SimulacionComputacional/P12/P12.R', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P12/P12.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P12/P12.R', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
contadores
source('~/GitHub/SimulacionComputacional/P12/P12.R', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
contadores
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
contadores
source('~/.active-rstudio-document', echo=TRUE)
contadores
source('~/.active-rstudio-document', echo=TRUE)
contadores
source('~/.active-rstudio-document', echo=TRUE)
contadores
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
aciertos
View(aciertos)
source('~/.active-rstudio-document', echo=TRUE)
aciertos
sum(aciertos)
source('~/.active-rstudio-document', echo=TRUE)
AciertosP
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P12/original.R')
source('~/GitHub/SimulacionComputacional/P12/P12p.R')
setwd("~/GitHub/SimulacionComputacional/P12")
source('~/GitHub/SimulacionComputacional/P12/P12T.R', echo=TRUE)
boxplot(Tiempo~tipo*nPrueba,data=Resultados,col = "lightgray",border=c("Green","Blue"),xlab="Número de soluciones ",ylab="Tiempo (s)")
legend("topleft", inset=.02,
c("Original","Paralelizado"), fill=c("Green","Blue"), horiz=TRUE, cex=0.8,box.lty = 0)
png("P12T.png",width=800, height=1000,pointsize = 15)
boxplot(Tiempo~tipo*nPrueba,data=Resultados,col = "lightgray",border=c("Green","Blue"),xlab="Número de soluciones ",ylab="Tiempo (s)")
legend("topleft", inset=.02,
c("Original","Paralelizado"), fill=c("Green","Blue"), horiz=TRUE, cex=0.8,box.lty = 0)
graphics.off()
png("P12T.png",width=800, height=1000,pointsize = 15)
boxplot(Tiempo~tipo*nPrueba,data=Resultados,col = c("green","blue"),border=c("Green","Blue"),xlab="Número de soluciones ",ylab="Tiempo (s)")
legend("topleft", inset=.02,
c("Original","Paralelizado"), fill=c("Green","Blue"), horiz=TRUE, cex=0.8,box.lty = 0)
graphics.off()
png("P12T.png",width=800, height=1000,pointsize = 15)
boxplot(Tiempo~tipo*nPrueba,data=Resultados,col = c("chartreuse","dodgerblue"),border=c("chartreuse4","dodgerblue4"),xlab="Número de soluciones ",ylab="Tiempo (s)")
legend("topleft", inset=.02,
c("Original","Paralelizado"), fill=c("Green","Blue"), horiz=TRUE, cex=0.8,box.lty = 0)
png("P12T.png",width=800, height=1000,pointsize = 15)
boxplot(Tiempo~tipo*nPrueba,data=Resultados,col = c("chartreuse","dodgerblue"),border=c("chartreuse4","dodgerblue4"),xlab="Número de soluciones ",ylab="Tiempo (s)")
legend("topleft", inset=.02,
c("Original","Paralelizado"), fill=c("Green","Blue"), horiz=TRUE, cex=0.8,box.lty = 0)
graphics.off()
save.image(file = "Practica11chido.RData")
png("P12T.png",width=800, height=1000,pointsize = 15)
boxplot(Tiempo~tipo*nPrueba,data=Resultados,col = c("chartreuse","dodgerblue"),border=c("chartreuse4","dodgerblue4"),xlab="Número de soluciones ",ylab="Tiempo (s)")
legend("topleft", inset=.02,
c("Original","Paralelizado"), fill=c("chartreuse","chartreuse4"), horiz=TRUE, cex=0.8,box.lty = 0)
graphics.off()
png("P12T.png",width=800, height=1000,pointsize = 15)
boxplot(Tiempo~tipo*nPrueba,data=Resultados,col = c("chartreuse","dodgerblue"),border=c("chartreuse4","dodgerblue4"),xlab="Número de soluciones ",ylab="Tiempo (s)")
legend("topleft", inset=.02,
c("Original","Paralelizado"), fill=c("chartreuse","dodgerblue"), horiz=TRUE, cex=0.8,box.lty = 0)
graphics.off()
aciertos
sum(aciertos)
