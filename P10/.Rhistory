pesos <- generador.pesos(n, 15, 80)
valores <- generador.valores(pesos, 10, 500)
capacidad <- round(sum(pesos) * 0.65)
optimo <- knapsack(capacidad, pesos, valores)
init <- 200
p <- poblacion.inicial(n, init)
tam <- dim(p)[1]
assert(tam == init)
pm <- 1
rep <- 50
tmax <- 1
mejores <- double()
suppressMessages(library(doParallel))
registerDoParallel(makeCluster(detectCores() - 1))
for (iter in 1:tmax) {
p$obj <- NULL
p$fact <- NULL
#Paralelizar mutaciones
mutar<-function(p){
if (runif(1) < pm) {
p <- rbind(mutacion (p[i,], n))
}
return(p)
}
#for (i in 1:tam) { # cada objeto puede mutarse con probabilidad pm
# if (runif(1) < pm) {
#  p <- rbind(p, mutacion(p[i,], n))
#}
#}
pi<-rbind(p, foreach(i=1:tam, .combine=cbind) %dopar% mutar(p))
}
Tinicial=Sys.time()
library(testit)
knapsack <- function(cap, peso, valor) {
n <- length(peso)
pt <- sum(peso)
assert(n == length(valor))
vt <- sum(valor)
if (pt < cap) {
return(vt)
} else {
filas <- cap + 1
cols <- n + 1
tabla <- matrix(rep(-Inf, filas * cols),
nrow = filas, ncol = cols)
for (fila in 1:filas) {
tabla[fila, 1] <- 0
}
rownames(tabla) <- 0:cap
colnames(tabla) <- c(0, valor)
for (objeto in 1:n) {
for (acum in 1:(cap+1)) { # consideramos cada fila de la tabla
anterior <- acum - peso[objeto]
if (anterior > 0) { # si conocemos una combinacion con ese peso
tabla[acum, objeto + 1] <- max(tabla[acum, objeto], tabla[anterior, objeto] + valor[objeto])
}
}
}
return(max(tabla))
}
}
factible <- function(seleccion, pesos, capacidad) {
return(sum(seleccion * pesos) <= capacidad)
}
objetivo <- function(seleccion, valores) {
return(sum(seleccion * valores))
}
normalizar <- function(data) {
menor <- min(data)
mayor <- max(data)
rango <- mayor - menor
data <- data - menor # > 0
return(data / rango) # entre 0 y 1
}
generador.pesos <- function(cuantos, min, max) {
return(sort(round(normalizar(rnorm(cuantos)) * (max - min) + min)))
}
generador.valores <- function(pesos, min, max) {
n <- length(pesos)
valores <- double()
for (i in 1:n) {
media <- pesos[n]
desv <- runif(1)
valores <- c(valores, rnorm(1, media, desv))
}
valores <- normalizar(valores) * (max - min) + min
return(valores)
}
poblacion.inicial <- function(n, tam) {
pobl <- matrix(rep(FALSE, tam * n), nrow = tam, ncol = n)
for (i in 1:tam) {
pobl[i,] <- round(runif(n))
}
return(as.data.frame(pobl))
}
mutacion <- function(sol, n) {
pos <- sample(1:n, 1)
mut <- sol
mut[pos] <- (!sol[pos]) * 1
return(mut)
}
reproduccion <- function(x, y, n) {
pos <- sample(2:(n-1), 1)
xy <- c(x[1:pos], y[(pos+1):n])
yx <- c(y[1:pos], x[(pos+1):n])
return(c(xy, yx))
}
n <- 50
pesos <- generador.pesos(n, 15, 80)
valores <- generador.valores(pesos, 10, 500)
capacidad <- round(sum(pesos) * 0.65)
optimo <- knapsack(capacidad, pesos, valores)
init <- 200
p <- poblacion.inicial(n, init)
tam <- dim(p)[1]
assert(tam == init)
pm <- 1
rep <- 50
tmax <- 1
mejores <- double()
suppressMessages(library(doParallel))
registerDoParallel(makeCluster(detectCores() - 1))
for (iter in 1:tmax) {
p$obj <- NULL
p$fact <- NULL
#Paralelizar mutaciones
mutar<-function(p){
if (runif(1) < pm) {
p <- rbind(mutacion (p[i,], n))
}
return(p)
}
#for (i in 1:tam) { # cada objeto puede mutarse con probabilidad pm
# if (runif(1) < pm) {
#  p <- rbind(p, mutacion(p[i,], n))
#}
#}
pi<-cbind(p, foreach(i=1:tam, .combine=rbind) %dopar% mutar(p))
}
source('~/GitHub/SimulacionComputacional/P10/p10.R', echo=TRUE)
Tinicial=Sys.time()
library(testit)
knapsack <- function(cap, peso, valor) {
n <- length(peso)
pt <- sum(peso)
assert(n == length(valor))
vt <- sum(valor)
if (pt < cap) {
return(vt)
} else {
filas <- cap + 1
cols <- n + 1
tabla <- matrix(rep(-Inf, filas * cols),
nrow = filas, ncol = cols)
for (fila in 1:filas) {
tabla[fila, 1] <- 0
}
rownames(tabla) <- 0:cap
colnames(tabla) <- c(0, valor)
for (objeto in 1:n) {
for (acum in 1:(cap+1)) { # consideramos cada fila de la tabla
anterior <- acum - peso[objeto]
if (anterior > 0) { # si conocemos una combinacion con ese peso
tabla[acum, objeto + 1] <- max(tabla[acum, objeto], tabla[anterior, objeto] + valor[objeto])
}
}
}
return(max(tabla))
}
}
factible <- function(seleccion, pesos, capacidad) {
return(sum(seleccion * pesos) <= capacidad)
}
objetivo <- function(seleccion, valores) {
return(sum(seleccion * valores))
}
normalizar <- function(data) {
menor <- min(data)
mayor <- max(data)
rango <- mayor - menor
data <- data - menor # > 0
return(data / rango) # entre 0 y 1
}
generador.pesos <- function(cuantos, min, max) {
return(sort(round(normalizar(rnorm(cuantos)) * (max - min) + min)))
}
generador.valores <- function(pesos, min, max) {
n <- length(pesos)
valores <- double()
for (i in 1:n) {
media <- pesos[n]
desv <- runif(1)
valores <- c(valores, rnorm(1, media, desv))
}
valores <- normalizar(valores) * (max - min) + min
return(valores)
}
poblacion.inicial <- function(n, tam) {
pobl <- matrix(rep(FALSE, tam * n), nrow = tam, ncol = n)
for (i in 1:tam) {
pobl[i,] <- round(runif(n))
}
return(as.data.frame(pobl))
}
mutacion <- function(sol, n) {
pos <- sample(1:n, 1)
mut <- sol
mut[pos] <- (!sol[pos]) * 1
return(mut)
}
reproduccion <- function(x, y, n) {
pos <- sample(2:(n-1), 1)
xy <- c(x[1:pos], y[(pos+1):n])
yx <- c(y[1:pos], x[(pos+1):n])
return(c(xy, yx))
}
n <- 50
pesos <- generador.pesos(n, 15, 80)
valores <- generador.valores(pesos, 10, 500)
capacidad <- round(sum(pesos) * 0.65)
optimo <- knapsack(capacidad, pesos, valores)
init <- 200
p <- poblacion.inicial(n, init)
tam <- dim(p)[1]
assert(tam == init)
pm <- 1
rep <- 50
tmax <- 1
mejores <- double()
suppressMessages(library(doParallel))
registerDoParallel(makeCluster(detectCores() - 1))
for (iter in 1:tmax) {
p$obj <- NULL
p$fact <- NULL
#Paralelizar mutaciones
mutar<-function(p){
if (runif(1) < pm) {
p <- rbind(mutacion (p[i,], n))
}
return(p)
}
#for (i in 1:tam) { # cada objeto puede mutarse con probabilidad pm
# if (runif(1) < pm) {
#  p <- rbind(p, mutacion(p[i,], n))
#}
#}
pi<-rbind(p, foreach(i=1:tam, .combine=c) %dopar% mutar(p))
}
View(pi)
View(pi)
source('~/GitHub/SimulacionComputacional/P10/p10.R', echo=TRUE)
Tinicial=Sys.time()
library(testit)
knapsack <- function(cap, peso, valor) {
n <- length(peso)
pt <- sum(peso)
assert(n == length(valor))
vt <- sum(valor)
if (pt < cap) {
return(vt)
} else {
filas <- cap + 1
cols <- n + 1
tabla <- matrix(rep(-Inf, filas * cols),
nrow = filas, ncol = cols)
for (fila in 1:filas) {
tabla[fila, 1] <- 0
}
rownames(tabla) <- 0:cap
colnames(tabla) <- c(0, valor)
for (objeto in 1:n) {
for (acum in 1:(cap+1)) { # consideramos cada fila de la tabla
anterior <- acum - peso[objeto]
if (anterior > 0) { # si conocemos una combinacion con ese peso
tabla[acum, objeto + 1] <- max(tabla[acum, objeto], tabla[anterior, objeto] + valor[objeto])
}
}
}
return(max(tabla))
}
}
factible <- function(seleccion, pesos, capacidad) {
return(sum(seleccion * pesos) <= capacidad)
}
objetivo <- function(seleccion, valores) {
return(sum(seleccion * valores))
}
normalizar <- function(data) {
menor <- min(data)
mayor <- max(data)
rango <- mayor - menor
data <- data - menor # > 0
return(data / rango) # entre 0 y 1
}
generador.pesos <- function(cuantos, min, max) {
return(sort(round(normalizar(rnorm(cuantos)) * (max - min) + min)))
}
generador.valores <- function(pesos, min, max) {
n <- length(pesos)
valores <- double()
for (i in 1:n) {
media <- pesos[n]
desv <- runif(1)
valores <- c(valores, rnorm(1, media, desv))
}
valores <- normalizar(valores) * (max - min) + min
return(valores)
}
poblacion.inicial <- function(n, tam) {
pobl <- matrix(rep(FALSE, tam * n), nrow = tam, ncol = n)
for (i in 1:tam) {
pobl[i,] <- round(runif(n))
}
return(as.data.frame(pobl))
}
mutacion <- function(sol, n) {
pos <- sample(1:n, 1)
mut <- sol
mut[pos] <- (!sol[pos]) * 1
return(mut)
}
reproduccion <- function(x, y, n) {
pos <- sample(2:(n-1), 1)
xy <- c(x[1:pos], y[(pos+1):n])
yx <- c(y[1:pos], x[(pos+1):n])
return(c(xy, yx))
}
n <- 50
pesos <- generador.pesos(n, 15, 80)
valores <- generador.valores(pesos, 10, 500)
capacidad <- round(sum(pesos) * 0.65)
optimo <- knapsack(capacidad, pesos, valores)
init <- 200
p <- poblacion.inicial(n, init)
tam <- dim(p)[1]
assert(tam == init)
pm <- 1
rep <- 50
tmax <- 1
mejores <- double()
suppressMessages(library(doParallel))
registerDoParallel(makeCluster(detectCores() - 1))
for (iter in 1:tmax) {
p$obj <- NULL
p$fact <- NULL
#Paralelizar mutaciones
mutar<-function(p){
if (runif(1) < pm) {
p <- mutacion (p[i,], n)
}
return(p)
}
#for (i in 1:tam) { # cada objeto puede mutarse con probabilidad pm
# if (runif(1) < pm) {
#  p <- rbind(p, mutacion(p[i,], n))
#}
#}
pi<-rbind(p, foreach(i=1:tam, .combine=c) %dopar% mutar(p))
}
Tinicial=Sys.time()
library(testit)
knapsack <- function(cap, peso, valor) {
n <- length(peso)
pt <- sum(peso)
assert(n == length(valor))
vt <- sum(valor)
if (pt < cap) {
return(vt)
} else {
filas <- cap + 1
cols <- n + 1
tabla <- matrix(rep(-Inf, filas * cols),
nrow = filas, ncol = cols)
for (fila in 1:filas) {
tabla[fila, 1] <- 0
}
rownames(tabla) <- 0:cap
colnames(tabla) <- c(0, valor)
for (objeto in 1:n) {
for (acum in 1:(cap+1)) { # consideramos cada fila de la tabla
anterior <- acum - peso[objeto]
if (anterior > 0) { # si conocemos una combinacion con ese peso
tabla[acum, objeto + 1] <- max(tabla[acum, objeto], tabla[anterior, objeto] + valor[objeto])
}
}
}
return(max(tabla))
}
}
factible <- function(seleccion, pesos, capacidad) {
return(sum(seleccion * pesos) <= capacidad)
}
objetivo <- function(seleccion, valores) {
return(sum(seleccion * valores))
}
normalizar <- function(data) {
menor <- min(data)
mayor <- max(data)
rango <- mayor - menor
data <- data - menor # > 0
return(data / rango) # entre 0 y 1
}
generador.pesos <- function(cuantos, min, max) {
return(sort(round(normalizar(rnorm(cuantos)) * (max - min) + min)))
}
generador.valores <- function(pesos, min, max) {
n <- length(pesos)
valores <- double()
for (i in 1:n) {
media <- pesos[n]
desv <- runif(1)
valores <- c(valores, rnorm(1, media, desv))
}
valores <- normalizar(valores) * (max - min) + min
return(valores)
}
poblacion.inicial <- function(n, tam) {
pobl <- matrix(rep(FALSE, tam * n), nrow = tam, ncol = n)
for (i in 1:tam) {
pobl[i,] <- round(runif(n))
}
return(as.data.frame(pobl))
}
mutacion <- function(sol, n) {
pos <- sample(1:n, 1)
mut <- sol
mut[pos] <- (!sol[pos]) * 1
return(mut)
}
reproduccion <- function(x, y, n) {
pos <- sample(2:(n-1), 1)
xy <- c(x[1:pos], y[(pos+1):n])
yx <- c(y[1:pos], x[(pos+1):n])
return(c(xy, yx))
}
n <- 50
pesos <- generador.pesos(n, 15, 80)
valores <- generador.valores(pesos, 10, 500)
capacidad <- round(sum(pesos) * 0.65)
optimo <- knapsack(capacidad, pesos, valores)
init <- 200
p <- poblacion.inicial(n, init)
tam <- dim(p)[1]
assert(tam == init)
pm <- 1
rep <- 50
tmax <- 1
mejores <- double()
suppressMessages(library(doParallel))
registerDoParallel(makeCluster(detectCores() - 1))
for (iter in 1:tmax) {
p$obj <- NULL
p$fact <- NULL
#Paralelizar mutaciones
mutar<-function(p){
if (runif(1) < pm) {
p <- mutacion (p[i,], n)
}
return(p)
}
#for (i in 1:tam) { # cada objeto puede mutarse con probabilidad pm
# if (runif(1) < pm) {
#  p <- rbind(p, mutacion(p[i,], n))
#}
#}
pi<-rbind(p, foreach(i=1:tam, .combine=cbind) %dopar% mutar(p))
}
source('~/GitHub/SimulacionComputacional/P10/p10.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P10/p10.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P10/p10.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P10/p10.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P10/p10.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P10/p10.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P10/p10.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P10/p10.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P10/p10.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P10/p10.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P10/p10.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P10/p10.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P10/p10.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P10/p10.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P10/p10.R', echo=TRUE)
View(pi)
View(pi)
source('~/GitHub/SimulacionComputacional/P10/p10.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P10/p10.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P10/p10.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P10/p10.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P10/p10.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P10/p10.R', echo=TRUE)
init <- 200
source('~/GitHub/SimulacionComputacional/P10/p10.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P10/p10.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P10/p10.R', echo=TRUE)
View(p)
View(p)
View(pi)
View(pi)
source('~/GitHub/SimulacionComputacional/P10/p10.R', echo=TRUE)
View(pi)
View(pi)
source('~/GitHub/SimulacionComputacional/P6/p6paralelizado/p6.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P10/p10.R', echo=TRUE)
p
source('~/GitHub/SimulacionComputacional/P10/p10.R', echo=TRUE)
View(p)
View(p)
source('~/GitHub/SimulacionComputacional/P10/p10.R', echo=TRUE)
install.packages("reshape2")
source('~/GitHub/SimulacionComputacional/P10/p10.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P10/p10.R', echo=TRUE)
install.packages("plyr")
