if (urna$tam > 1) { # no tiene caso romper si no se puede
cumulos <- c(cumulos, romperse(urna$tam, urna$num))
} else {
cumulos <- c(cumulos, rep(1, urna$num))
}
return(cumulos)
}
source('~/.active-rstudio-document', encoding = 'UTF-8', echo=TRUE)
source('~/.active-rstudio-document', encoding = 'UTF-8', echo=TRUE)
traceback()
source('~/.active-rstudio-document', encoding = 'UTF-8', echo=TRUE)
source('~/.active-rstudio-document', encoding = 'UTF-8', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P8/p8paralelizado.R', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
hist(cumulos,
#, breaks=seq(0, tope, 50),
main=paste("Paso", paso, "con ambos fen\u{00f3}menos"), freq=FALSE,
ylim=c(0, 0.05), xlab="Tama\u{00f1}o", ylab="Frecuencia relativa")
source('~/GitHub/SimulacionComputacional/P8/p8paralelizado.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P8/p8paralelizado.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P8/p8paralelizado.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P8/p8paralelizado.R', echo=TRUE)
png(paste("p8_ct", tl, ".png", sep=""), width=300, height=300)
#tope <- 50 * ceiling(max(cumulos) / 50)
hist(cumulos,
#breaks=seq(0, tope, 50),
main=paste("Paso", paso, "con ambos fen\u{00f3}menos"), freq=FALSE,
ylim=c(0, 0.3), xlab="Tama\u{00f1}o", ylab="Frecuencia relativa")
graphics.off()
n <- 50
p <- data.frame(x = rnorm(n), y=rnorm(n), c=rnorm(n))
View(p)
View(p)
n <- 50
p <- data.frame(x = rnorm(n), y=rnorm(n), c=rnorm(n))
View(p)
View(p)
density(p)
hist(p)
hist(p$x)
hist(p$y)
hist(p$c)
xmax <- max(p$x)
xmin <- min(p$x)
p$x <- (p$x - xmin) / (xmax - xmin) # ahora son de 0 a 1
hist(p$x)
ymax <- max(p$y)
ymin <- min(p$y)
p$y <- (p$y - ymin) / (ymax - ymin) # las y tambien
cmax <- max(p$c)
cmin <- min(p$c)
p$c <- 2 * (p$c - cmin) / (cmax - cmin) - 1 # cargas son entre -1 y 1
library(lattice)
p$g <- round(5 * p$c) # coloreamos segun la carga a 11 niveles de -5 a 5
View(p)
View(p)
paso <- floor(256 / 10)
niveles <- seq(0, 255, paso)
print(length(niveles))
colores <- rgb(niveles, rep(0, 11), rev(niveles), max=255)
datos=rep(0,11)
datos
datos
datos=c(1,2,3,4,5)
datos
rev(datos)
collor=rgb(0,1,0)
collor
collor=rgb(1,1,0)
collor
colores <- rgb(niveles, rep(0, 11), rev(niveles), max=255)
print(colores)
png("p9i.png")
xyplot(y ~ x, group=g, data=p, auto.key=list(space="right"),
xlab="X", ylab="Y", main="Part\u{00ed}culas generadas",
par.settings = list(superpose.symbol = list(pch = 15, cex = 1.5,
col = colores)))
graphics.off()
xyplot(y ~ x, group=g, data=p, auto.key=list(space="right"),
xlab="X", ylab="Y", main="Part\u{00ed}culas generadas",
par.settings = list(superpose.symbol = list(pch = 15, cex = 1.5,
col = colores)))
n <- 50
p <- data.frame(x = rnorm(n), y=rnorm(n), c=rnorm(n))
xmax <- max(p$x)
xmin <- min(p$x)
p$x <- (p$x - xmin) / (xmax - xmin) # ahora son de 0 a 1
ymax <- max(p$y)
ymin <- min(p$y)
p$y <- (p$y - ymin) / (ymax - ymin) # las y tambien
cmax <- max(p$c)
cmin <- min(p$c)
p$c <- 2 * (p$c - cmin) / (cmax - cmin) - 1 # cargas son entre -1 y 1
p$g <- round(5 * p$c) # coloreamos segun la carga a 11 niveles de -5 a 5
paso <- floor(256 / 10)
niveles <- seq(0, 255, paso)
colores <- rgb(niveles, rep(0, 11), rev(niveles), max=255)
#png("p9i.png")
library(lattice)
xyplot(y ~ x, group=g, data=p, auto.key=list(space="right"),
xlab="X", ylab="Y", main="Part\u{00ed}culas generadas",
par.settings = list(superpose.symbol = list(pch = 15, cex = 1.5,
col = colores)))
#graphics.off()
eps <- 0.001
fuerza <- function(i) {
xi <- p[i,]$x
yi <- p[i,]$y
ci <- p[i,]$c
fx <- 0
fy <- 0
for (j in 1:n) {
cj <- p[j,]$c
dir <- (-1)^(1 + 1 * (ci * cj < 0))
dx <- xi - p[j,]$x
dy <- yi - p[j,]$y
factor <- dir * abs(ci - cj) / (sqrt(dx^2 + dy^2) + eps)
fx <- fx - dx * factor
fy <- fy - dy * factor
}
return(c(fx, fy))
}
suppressMessages(library(doParallel))
registerDoParallel(makeCluster(detectCores() - 1))
system("rm -f p9_t*.png") # borramos anteriores en el caso que lo hayamos corrido
n <- 50
p <- data.frame(x = rnorm(n), y=rnorm(n), c=rnorm(n))
xmax <- max(p$x)
xmin <- min(p$x)
p$x <- (p$x - xmin) / (xmax - xmin) # ahora son de 0 a 1
ymax <- max(p$y)
ymin <- min(p$y)
p$y <- (p$y - ymin) / (ymax - ymin) # las y tambien
cmax <- max(p$c)
cmin <- min(p$c)
p$c <- 2 * (p$c - cmin) / (cmax - cmin) - 1 # cargas son entre -1 y 1
library(lattice)
p$g <- round(5 * p$c) # coloreamos segun la carga a 11 niveles de -5 a 5
paso <- floor(256 / 10)
niveles <- seq(0, 255, paso)
print(length(niveles))
colores <- rgb(niveles, rep(0, 11), rev(niveles), max=255)
print(colores)
#png("p9i.png")
xyplot(y ~ x, group=g, data=p, auto.key=list(space="right"),
xlab="X", ylab="Y", main="Part\u{00ed}culas generadas",
par.settings = list(superpose.symbol = list(pch = 15, cex = 1.5,
col = colores)))
#graphics.off()
xi <- p[i,]$x
xi <- p[1,]$x
View(p)
View(p)
xi <- p[2,]$x
n <- 50
p <- data.frame(x = rnorm(n), y=rnorm(n), c=rnorm(n))
xmax <- max(p$x)
xmin <- min(p$x)
p$x <- (p$x - xmin) / (xmax - xmin) # ahora son de 0 a 1
ymax <- max(p$y)
ymin <- min(p$y)
p$y <- (p$y - ymin) / (ymax - ymin) # las y tambien
cmax <- max(p$c)
cmin <- min(p$c)
p$c <- 2 * (p$c - cmin) / (cmax - cmin) - 1 # cargas son entre -1 y 1
p$g <- round(5 * p$c) # coloreamos segun la carga a 11 niveles de -5 a 5
paso <- floor(256 / 10)
niveles <- seq(0, 255, paso)
colores <- rgb(niveles, rep(0, 11), rev(niveles), max=255)
#png("p9i.png")
library(lattice)
xyplot(y ~ x, group=g, data=p, auto.key=list(space="right"),
xlab="X", ylab="Y", main="Part\u{00ed}culas generadas",
par.settings = list(superpose.symbol = list(pch = 15, cex = 1.5,
col = colores)))
#graphics.off()
eps <- 0.001
fuerza <- function(i) {
xi <- p[i,]$x
yi <- p[i,]$y
ci <- p[i,]$c
fx <- 0
fy <- 0
for (j in 1:n) {
cj <- p[j,]$c
dir <- (-1)^(1 + 1 * (ci * cj < 0))
dx <- xi - p[j,]$x
dy <- yi - p[j,]$y
factor <- dir * abs(ci - cj) / (sqrt(dx^2 + dy^2) + eps)
fx <- fx - dx * factor
fy <- fy - dy * factor
}
return(c(fx, fy))
}
suppressMessages(library(doParallel))
registerDoParallel(makeCluster(detectCores() - 1))
system("rm -f p9_t*.png") # borramos anteriores en el caso que lo hayamos corrido
tmax <- 100
digitos <- floor(log(tmax, 10)) + 1
tl <- "0"
while (nchar(tl) < digitos) {
tl <- paste("0", tl, sep="")
}
#png(paste("p9_t", tl, ".png", sep=""))
plot(p$x, p$y, col=colores[p$g+6], pch=15, cex=1.5, xlim=c(-0.1, 1.1), ylim=c(-0.1, 1.1),
main="Estado inicial", xlab="X", ylab="Y")
#graphics.off()
n <- 50
p <- data.frame(x = rnorm(n), y=rnorm(n), c=rnorm(n))
xmax <- max(p$x)
xmin <- min(p$x)
p$x <- (p$x - xmin) / (xmax - xmin) # ahora son de 0 a 1
ymax <- max(p$y)
ymin <- min(p$y)
p$y <- (p$y - ymin) / (ymax - ymin) # las y tambien
cmax <- max(p$c)
cmin <- min(p$c)
p$c <- 2 * (p$c - cmin) / (cmax - cmin) - 1 # cargas son entre -1 y 1
p$g <- round(5 * p$c) # coloreamos segun la carga a 11 niveles de -5 a 5
paso <- floor(256 / 10)
niveles <- seq(0, 255, paso)
colores <- rgb(niveles, rep(0, 11), rev(niveles), max=255)
#png("p9i.png")
library(lattice)
xyplot(y ~ x, group=g, data=p, auto.key=list(space="right"),
xlab="X", ylab="Y", main="Part\u{00ed}culas generadas",
par.settings = list(superpose.symbol = list(pch = 15, cex = 1.5,
col = colores)))
#graphics.off()
eps <- 0.001
fuerza <- function(i) {
xi <- p[i,]$x
yi <- p[i,]$y
ci <- p[i,]$c
fx <- 0
fy <- 0
for (j in 1:n) {
cj <- p[j,]$c
dir <- (-1)^(1 + 1 * (ci * cj < 0))
dx <- xi - p[j,]$x
dy <- yi - p[j,]$y
factor <- dir * abs(ci - cj) / (sqrt(dx^2 + dy^2) + eps)
fx <- fx - dx * factor
fy <- fy - dy * factor
}
return(c(fx, fy))
}
suppressMessages(library(doParallel))
registerDoParallel(makeCluster(detectCores() - 1))
system("rm -f p9_t*.png") # borramos anteriores en el caso que lo hayamos corrido
tmax <- 100
digitos <- floor(log(tmax, 10)) + 1
tl <- "0"
while (nchar(tl) < digitos) {
tl <- paste("0", tl, sep="")
}
png(paste("p9_t", tl, ".png", sep=""))
plot(p$x, p$y, col=colores[p$g+6], pch=15, cex=1.5, xlim=c(-0.1, 1.1), ylim=c(-0.1, 1.1),
main="Estado inicial", xlab="X", ylab="Y")
graphics.off()
setwd("~/GitHub/SimulacionComputacional/P9")
n <- 50
p <- data.frame(x = rnorm(n), y=rnorm(n), c=rnorm(n))
xmax <- max(p$x)
xmin <- min(p$x)
p$x <- (p$x - xmin) / (xmax - xmin) # ahora son de 0 a 1
ymax <- max(p$y)
ymin <- min(p$y)
p$y <- (p$y - ymin) / (ymax - ymin) # las y tambien
cmax <- max(p$c)
cmin <- min(p$c)
p$c <- 2 * (p$c - cmin) / (cmax - cmin) - 1 # cargas son entre -1 y 1
p$g <- round(5 * p$c) # coloreamos segun la carga a 11 niveles de -5 a 5
paso <- floor(256 / 10)
niveles <- seq(0, 255, paso)
colores <- rgb(niveles, rep(0, 11), rev(niveles), max=255)
#png("p9i.png")
library(lattice)
xyplot(y ~ x, group=g, data=p, auto.key=list(space="right"),
xlab="X", ylab="Y", main="Part\u{00ed}culas generadas",
par.settings = list(superpose.symbol = list(pch = 15, cex = 1.5,
col = colores)))
#graphics.off()
eps <- 0.001
fuerza <- function(i) {
xi <- p[i,]$x
yi <- p[i,]$y
ci <- p[i,]$c
fx <- 0
fy <- 0
for (j in 1:n) {
cj <- p[j,]$c
dir <- (-1)^(1 + 1 * (ci * cj < 0))
dx <- xi - p[j,]$x
dy <- yi - p[j,]$y
factor <- dir * abs(ci - cj) / (sqrt(dx^2 + dy^2) + eps)
fx <- fx - dx * factor
fy <- fy - dy * factor
}
return(c(fx, fy))
}
suppressMessages(library(doParallel))
registerDoParallel(makeCluster(detectCores() - 1))
system("rm -f p9_t*.png") # borramos anteriores en el caso que lo hayamos corrido
tmax <- 100
digitos <- floor(log(tmax, 10)) + 1
tl <- "0"
while (nchar(tl) < digitos) {
tl <- paste("0", tl, sep="")
}
png(paste("p9_t", tl, ".png", sep=""))
plot(p$x, p$y, col=colores[p$g+6], pch=15, cex=1.5, xlim=c(-0.1, 1.1), ylim=c(-0.1, 1.1),
main="Estado inicial", xlab="X", ylab="Y")
graphics.off()
n <- 50
p <- data.frame(x = rnorm(n), y=rnorm(n), c=rnorm(n))
xmax <- max(p$x)
xmin <- min(p$x)
p$x <- (p$x - xmin) / (xmax - xmin) # ahora son de 0 a 1
ymax <- max(p$y)
ymin <- min(p$y)
p$y <- (p$y - ymin) / (ymax - ymin) # las y tambien
cmax <- max(p$c)
cmin <- min(p$c)
p$c <- 2 * (p$c - cmin) / (cmax - cmin) - 1 # cargas son entre -1 y 1
p$g <- round(5 * p$c) # coloreamos segun la carga a 11 niveles de -5 a 5
paso <- floor(256 / 10)
niveles <- seq(0, 255, paso)
colores <- rgb(niveles, rep(0, 11), rev(niveles), max=255)
png("p9i.png")
library(lattice)
xyplot(y ~ x, group=g, data=p, auto.key=list(space="right"),
xlab="X", ylab="Y", main="Part\u{00ed}culas generadas",
par.settings = list(superpose.symbol = list(pch = 15, cex = 1.5,
col = colores)))
graphics.off()
eps <- 0.001
fuerza <- function(i) {
xi <- p[i,]$x
yi <- p[i,]$y
ci <- p[i,]$c
fx <- 0
fy <- 0
for (j in 1:n) {
cj <- p[j,]$c
dir <- (-1)^(1 + 1 * (ci * cj < 0))
dx <- xi - p[j,]$x
dy <- yi - p[j,]$y
factor <- dir * abs(ci - cj) / (sqrt(dx^2 + dy^2) + eps)
fx <- fx - dx * factor
fy <- fy - dy * factor
}
return(c(fx, fy))
}
suppressMessages(library(doParallel))
registerDoParallel(makeCluster(detectCores() - 1))
system("rm -f p9_t*.png") # borramos anteriores en el caso que lo hayamos corrido
tmax <- 100
digitos <- floor(log(tmax, 10)) + 1
tl <- "0"
while (nchar(tl) < digitos) {
tl <- paste("0", tl, sep="")
}
png(paste("p9_t", tl, ".png", sep=""))
plot(p$x, p$y, col=colores[p$g+6], pch=15, cex=1.5, xlim=c(-0.1, 1.1), ylim=c(-0.1, 1.1),
main="Estado inicial", xlab="X", ylab="Y")
graphics.off()
for (iter in 1:tmax) {
f <- foreach(i = 1:n, .combine=c) %dopar% fuerza(i)
delta <- 0.02 / max(abs(f)) # que nadie desplace una paso muy largo
p$x <- foreach(i = 1:n, .combine=c) %dopar% max(min(p[i,]$x + delta * f[c(TRUE, FALSE)][i], 1), 0)
p$y <- foreach(i = 1:n, .combine=c) %dopar% max(min(p[i,]$y + delta * f[c(FALSE, TRUE)][i], 1), 0)
tl <- paste(iter, "", sep="")
while (nchar(tl) < digitos) {
tl <- paste("0", tl, sep="")
}
png(paste("p9_t", tl, ".png", sep=""))
plot(p$x, p$y, col=colores[p$g+6], pch=15, cex=1.5, xlim=c(-0.1, 1.1), ylim=c(-0.1, 1.1),
main=paste("Paso", iter), xlab="X", ylab="Y")
graphics.off()
}
stopImplicitCluster()
source('~/GitHub/SimulacionComputacional/P9/p9.R', echo=TRUE)
n <- 50
p <- data.frame(x = rnorm(n), y=rnorm(n), c=rnorm(n), m=rnorm(n))
mmax <- max(p$m)
mmin <- min(p$m)
p$m <- (p$m-mmin)/ (mmax-mmin)
n <- 50
p <- data.frame(x = rnorm(n), y=rnorm(n), c=rnorm(n), m=rnorm(n))
xmax <- max(p$x)
xmin <- min(p$x)
p$x <- (p$x - xmin) / (xmax - xmin) # ahora son de 0 a 1
ymax <- max(p$y)
ymin <- min(p$y)
p$y <- (p$y - ymin) / (ymax - ymin) # las y tambien
cmax <- max(p$c)
cmin <- min(p$c)
mmax <- max(p$m)
mmin <- min(p$m)+0.01
p$m <- (p$m-mmin)/ (mmax-mmin)
p$c <- 2 * (p$c - cmin) / (cmax - cmin) - 1 # cargas son entre -1 y 1
p$g <- round(5 * p$c) # coloreamos segun la carga a 11 niveles de -5 a 5
n <- 50
p <- data.frame(x = rnorm(n), y=rnorm(n), c=rnorm(n), m=rnorm(n))
xmax <- max(p$x)
xmin <- min(p$x)
p$x <- (p$x - xmin) / (xmax - xmin) # ahora son de 0 a 1
ymax <- max(p$y)
ymin <- min(p$y)
p$y <- (p$y - ymin) / (ymax - ymin) # las y tambien
cmax <- max(p$c)
cmin <- min(p$c)
mmax <- max(p$m)
mmin <- min(p$m)+0.01
p$m <- (p$m-mmin)/ (mmax-mmin)
p$c <- 2 * (p$c - cmin) / (cmax - cmin) - 1 # cargas son entre -1 y 1
p$g <- round(5 * p$c) # coloreamos segun la carga a 11 niveles de -5 a 5
n <- 50
p <- data.frame(x = rnorm(n), y=rnorm(n), c=rnorm(n), m=rnorm(n))
xmax <- max(p$x)
xmin <- min(p$x)
p$x <- (p$x - xmin) / (xmax - xmin) # ahora son de 0 a 1
ymax <- max(p$y)
ymin <- min(p$y)
p$y <- (p$y - ymin) / (ymax - ymin) # las y tambien
cmax <- max(p$c)
cmin <- min(p$c)
mmax <- max(p$m)
mmin <- min(p$m)+0.01
p$m <- abs((p$m-mmin)/ (mmax-mmin))
library(lattice)
p$g <- round(5 * p$c) # coloreamos segun la carga a 11 niveles de -5 a 5
n <- 50
p <- data.frame(x = rnorm(n), y=rnorm(n), c=rnorm(n), m=rnorm(n))
xmax <- max(p$x)
xmin <- min(p$x)
p$x <- (p$x - xmin) / (xmax - xmin) # ahora son de 0 a 1
ymax <- max(p$y)
ymin <- min(p$y)
p$y <- (p$y - ymin) / (ymax - ymin) # las y tambien
cmax <- max(p$c)
cmin <- min(p$c)
mmax <- max(p$m)
mmin <- min(p$m)+0.01
p$m <- abs((p$m-mmin)/ (mmax-mmin))
p$c <- 2 * (p$c - cmin) / (cmax - cmin) - 1 # cargas son entre -1 y 1
p$g <- round(5 * p$c) # coloreamos segun la carga a 11 niveles de -5 a 5
paso <- floor(256 / 10)
niveles <- seq(0, 255, paso)
colores <- rgb(niveles, rep(0, 11), rev(niveles), max=255)
n <- 50
p <- data.frame(x = rnorm(n), y=rnorm(n), c=rnorm(n), m=rnorm(n))
xmax <- max(p$x)
xmin <- min(p$x)
p$x <- (p$x - xmin) / (xmax - xmin) # ahora son de 0 a 1
ymax <- max(p$y)
ymin <- min(p$y)
p$y <- (p$y - ymin) / (ymax - ymin) # las y tambien
cmax <- max(p$c)
cmin <- min(p$c)
mmax <- 5
mmin <- 10
p$m <- abs((p$m-mmin)/ (mmax-mmin))
p$c <- 2 * (p$c - cmin) / (cmax - cmin) - 1 # cargas son entre -1 y 1
p$g <- round(5 * p$c) # coloreamos segun la carga a 11 niveles de -5 a 5
p$c <- 2 * (p$c - cmin) / (cmax - cmin) - 1 # cargas son entre -1 y 1
n <- 50
p <- data.frame(x = rnorm(n), y=rnorm(n), c=rnorm(n), m=abs(rnorm(n)))
xmax <- max(p$x)
xmin <- min(p$x)
p$x <- (p$x - xmin) / (xmax - xmin) # ahora son de 0 a 1
ymax <- max(p$y)
ymin <- min(p$y)
p$y <- (p$y - ymin) / (ymax - ymin) # las y tambien
cmax <- max(p$c)
cmin <- min(p$c)
#mmax <- 5
#mmin <- 10
#p$m <- abs((p$m-mmin)/ (mmax-mmin))
p$c <- 2 * (p$c - cmin) / (cmax - cmin) - 1 # cargas son entre -1 y 1
p$g <- round(5 * p$c) # coloreamos segun la carga a 11 niveles de -5 a 5
dir <- (-1)^(1 + 1 * (-0.032 * 0.156 < 0))
dir
dir <- (-1)^(1 + 1 * (-0.032 * -0.156 < 0))
dir
dir <- (-1)^(1 + 1 * (-0.05462 * -0.935456 < 0))
dir
dir <- (-1)^(1 + 1 * (-0.05462 * 0.935456 < 0))
dir
setwd("~/GitHub/SimulacionComputacional/P9")
source('~/GitHub/SimulacionComputacional/P9/p9.R', echo=TRUE)
View(p)
View(p)
final<- data.frame()
final2<- data.frame()
final<- cbind(fx,fy,m,p)
final2<-rbind(final2,final)
source('~/GitHub/SimulacionComputacional/P9/p9.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P9/p9.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P9/p9.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P9/p9.R', echo=TRUE)
View(p)
View(p)
source('~/GitHub/SimulacionComputacional/P9/p9.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P9/p9.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P9/p9.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P9/p9.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P9/p9.R', echo=TRUE)
source('~/GitHub/SimulacionComputacional/P9/p9.R', echo=TRUE)
